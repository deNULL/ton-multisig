;; Simple wallet smart contract

() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}

() recv_external(slice in_msg) impure {
  ;; usual signature, seqno, expiry date
  var signature = in_msg~load_bits(512);
  var cs = in_msg;
  var (msg_seqno, valid_until) = (cs~load_uint(32), cs~load_uint(32));
  throw_if(35, valid_until < now());
  
  ;; pubkey of the person who signed this message
  ;; should be included in the list of allowed keys (within this wallet data)
  var signatory_pubkey = cs~load_uint(256);

  var ds = get_data().begin_parse();
  ;; seqno,
  ;; number of requests pending,
  ;; total number of stored keys, 
  ;; required number of signatures to complete signature
  var (stored_seqno, pending_count, param_n, param_k) =
    (ds~load_uint(32), ds~load_uint(16), ds~load_uint(8), ds~load_uint(8));

  throw_unless(33, msg_seqno == stored_seqno);
  throw_unless(34, check_signature(slice_hash(in_msg), signature, signatory_pubkey));

  ;; dict of {stored pubkey => #key},
  ;; dict of {#request => request},
  var (owners, pending) = (ds~load_dict(), ds~load_dict());
  ds.end_parse();

  ;; validate that signatory_pubkey is among stored keys
  var (_, found) = owners.udict_get?(256, signatory_pubkey);
  throw_unless(35, found);

  accept_message();

  if (pending.null?()) {
    pending = new_dict();
  }

  ;; iterate over pending requests and delete all expired ones
  var req_hash = -1;
  do {
    (req_hash, var request, var f) = pending.udict_get_next?(256, req_hash);
    if (f) {
      var (req_signs, req_body) = (request~load_dict(), request~load_ref());
      var req_body_slice = req_body.begin_parse();
      var (_, req_expiry, req_mode) = (
        req_body_slice~load_uint(32),
        req_body_slice~load_uint(32),
        req_body_slice~load_uint(8)
      );
      if (req_expiry < now()) {
        ;; TODO: not sure if we are allowed to remove entries while iterating
        pending~udict_delete_get?(256, req_hash);
      }
    }
  } until (~ f);

  ;; process new request
  cs~touch();
  while (cs.slice_refs()) {
    ;;var (req_expiry, req_mode) = (cs~load_uint(8), cs~load_uint(32));
    var req_body = cs~load_ref();
    var req_hash = cell_hash(req_body);
    var req_new_signs = cs~load_dict();

    ;; validate expiry
    var req_body_slice = req_body.begin_parse();
    var (req_seqno, req_expiry, req_mode) = (
      req_body_slice~load_uint(32),
      req_body_slice~load_uint(32),
      req_body_slice~load_uint(8)
    );

    throw_if(36, req_expiry < now());

    ;; check if this request is already pending
    var (req_data, found) = pending.udict_get?(256, req_hash);
    var req_sign_total = 0;
    var req_signs = new_dict();
    if (found) {
      req_sign_total = req_data~load_uint(8);
      req_signs = req_data~load_dict();
    } else {
      ;; request should contain actual seqno of this contract,
      ;; but it's validate only when the first batch of signatures arrive
      ;; (it cannot increase, because it's included in signed part,
      ;; and after the first accepted message it won't be equal to the contract's seqno)
      throw_unless(37, req_seqno == stored_seqno);
    }

    ;; merge new signatures into req_signs
    var pubkey = -1;
    do {
      (pubkey, var sign, var f) = req_new_signs.udict_get_next?(256, pubkey);
      if (f) {
        var (owner, owner_found) = owners.udict_get?(256, pubkey);
        ;; this signature does not belong to any owner
        throw_unless(38, owner_found);

        ;; check that signature is valid
        var req_signature = sign~load_bits(512);
        throw_unless(39, check_signature(req_hash, req_signature, pubkey));

        ;; check that this request was not signed by this owner previously
        ;; (to prevent adding same signature over and over again)
        var owner_idx = owner~load_uint(8);
        var (_, sign_found) = req_signs.udict_get?(8, owner_idx);
        ifnot (sign_found) {
          req_sign_total += 1;
          req_signs.udict_set_builder(8, owner_idx, begin_cell());
        }
      }
    } until (~ f);

    if (req_sign_total >= param_k) {
      ;; enough signatures to send this message
      send_raw_message(req_body_slice~load_ref(), req_mode);

      ;; make sure it's removed
      pending~udict_delete_get?(256, req_hash);
    } else {
      ;; store message as pending request
      pending~udict_set_builder(256, req_hash, begin_cell()
        .store_uint(req_sign_total, 8)
        .store_dict(req_signs)
        .store_ref(req_body));
    }
  }
  cs.end_parse();

  set_data(
    begin_cell()
      .store_uint(stored_seqno + 1, 32)
      .store_uint(pending_count, 16)
      .store_uint(param_n, 8)
      .store_uint(param_k, 8)
      .store_dict(owners)
      .store_dict(pending)
    .end_cell()
  );
}

(int, int, int, cell, cell) unpack_request(request) {
  var (req_signs, req_body) = (request~load_dict(), request~load_ref());
  var req_body_slice = req_body.begin_parse();
  var (req_seqno, req_expiry, req_mode) = (req_body_slice~load_uint(32), req_body_slice~load_uint(32), req_body_slice~load_uint(8));
  var req_msg = req_body_slice~load_ref();
  return (req_seqno, req_expiry, req_mode, req_msg, req_signs);
}

_ unpack_signatures(signs) {
  var l = nil;
  var owner_idx = (1 << 255) + ((1 << 255) - 1);
  do {
    (owner_idx, _, var f) = signs.udict_get_prev?(8, owner_idx);
    if (f) {
      l = cons(owner_idx, l);
    }
  } until (~ f);
  return l;
}

;; Get methods

int seqno() method_id {
  return get_data().begin_parse().preload_uint(32);
}

;; Returns number of pending requests

int pending_count() method_id {
  return get_data().begin_parse().skip_bits(32).preload_uint(16);
}

;; Returns n (total number of owners)

int param_n() method_id {
  return get_data().begin_parse().skip_bits(48).preload_uint(8);
}

;; Returns k (number of signatures required to send a message)

int param_k() method_id {
  return get_data().begin_parse().skip_bits(56).preload_uint(8);
}

;; Returns list of all owners

_ owners() method_id {
  var ds = get_data().begin_parse();
  var owners = ds~load_dict();

  var l = nil;
  var pubkey = (1 << 255) + ((1 << 255) - 1);
  do {
    (pubkey, var owner, var f) = owners.udict_get_prev?(256, pubkey);
    if (f) {
      l = cons(pair(pubkey, owner.preload_uint(8)), l);
    }
  } until (~ f);
  return l;
}

;; Returns list of all pending requests

_ pending() method_id {
  var ds = get_data().begin_parse();
  ds~load_dict();
  var pending = ds~load_dict();
  if (pending.null?()) {
    return nil;
  }

  var l = nil;
  var req_hash = (1 << 255) + ((1 << 255) - 1);
  do {
    (req_hash, var request, var f) = pending.udict_get_prev?(256, req_hash);
    if (f) {
      var (_, req_expiry, req_mode, req_msg, req_signs) = unpack_request(request);
      l = cons(tuple4(req_expiry, req_mode, req_msg, unpack_signatures(req_signs)), l);
    }
  } until (~ f);
  return l;
}

;; Returns all pending requests that are signed or not signed by a specific owner

_ pending_signed_by(int signatory_pubkey, int filter_signed) method_id {
  var ds = get_data().begin_parse();
  var owners = ds~load_dict();
  var (owner, owner_found) = owners.udict_get?(256, signatory_pubkey);
  ;; ifnot (owner_found) {
  ;;  return nil;
  ;;}
  throw_unless(36, owner_found);
  var owner_idx = owner~load_uint(8);

  var pending = ds~load_dict();
  if (pending.null?()) {
    return nil;
  }

  var l = nil;
  var req_hash = (1 << 255) + ((1 << 255) - 1);
  do {
    (req_hash, var request, var f) = pending.udict_get_prev?(256, req_hash);
    if (f) {
      var (_, req_expiry, req_mode, req_msg, req_signs) = unpack_request(request);
      var (_, sign_found) = req_signs.udict_get?(8, owner_idx);

      if (filter_signed == sign_found) {
        l = cons(tuple4(req_expiry, req_mode, req_msg, unpack_signatures(req_signs)), l);
      }
    }
  } until (~ f);
  return l;
}