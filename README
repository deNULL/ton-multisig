Сборка с геттерами:

func -o"my/multisig-code.fif" -P smartcont/stdlib.fc my/multisig-code.fc my/multisig-code-getters.fc

Без:

func -o"my/multisig-code.fif" -P smartcont/stdlib.fc my/multisig-code.fc

Баги/улучшения:

- не хватает метода udict_delete? (по аналогии с idict_delete?)

- зависание при использовании метода unpack_request

- ошибка с UNTILEND (в коде garbage collector'а)

- отказ от get-методов в пользу работы с данными из фифта (экономия места)

- было бы хорошо иметь механизм управления ассемблерным кодом из фифта (типа #ifdef), чтобы корректировать генерируемый код
(#ifdef в FunC -> #ifdef в асме -> #define в Fift -> в зависимости от наличия либо выкидывать кусок кода, либо нет)

Создание:

multisig-init.fif - создаем кошелек с n ключами, k требуется


multisig-append-keys.fif - добавляем ключ в код создания кошелька (TODO)





Apart from this basic functionality of the smart contract, you have to implement 

= get-methods that list all pending (partially signed) orders
orders

= get-methods that list all pending orders signed or not signed by a particular public key.
signedBy


Your interface Fift scripts should help the user:

= to create (BoC files with serialized) external messages with completely new orders (similarly to `wallet.fif` used by the simple wallet smart contract)

multisig-new-order.fif - создаем запрос на задание


= to extract and show the internal message (especially its destination address and value) and the list of signatures from a previously serialized external messages (loaded from a file)

multisig-show-order.fif - показать данные в запросе


= to add new signatures to such external messages using a local private key file (so that the holder of one private key might create an external message and send it by e-mail to the holder of another private key, who could add the second signature to the next holder and so on until the necessary amount of signatures is collected offline)

multisig-sign-order.fif - добавляем подпись в запрос


= to merge two external messages with the same body, but with different signature sets, into one external message with the union of these signature sets,

multisig-merge-orders.fif - объединить два запроса на одинаковое задание


= to create and sign a "new order" external message corresponding to a partially signed order recovered from the current state of the blockchain using one of the get-methods indicated above.

multisig-sign-sent-order.fif - импортируем существующее задание и делаем запрос на добавление подписи в него




Структура data:

32 бита: seqno
16 бит: pending, число запросов, ожидающих подписей
8 бит: n, число ключей в контракте
8 бит: k, число ключей, необходимых для отправки запроса

dict (публичный ключ => его 8 бит индекс)
dict (хэш запроса => инфо)
  для каждого запроса:
  8 бит: s, число подписей
  ref: тело запроса + mode (как в обычном кошельке) + expire_at
  dict (8 бит индекс ключа => 512-битная подпись)


Issues:
как использовать Bytes в кач-ве ключей dict?
как использовать Integer в кач-ве значений?


Сообщение:

512 бит подпись
32 бита: seqno
32 бита: valid_until
256 бит пуб ключ того, кто подписал _сообщение_ <- по факту тут будет ключ того, кто последним добавлял свою подпись
ref: тело запроса + mode (как в обычном кошельке) + expire_at
dict: 256-бит пубключ => 512-бит подпись запроса



Потрачено на инициализацию (5/3):
20000000000 - 19984905999 = 15094001 nano = 0.015 Gram


base_wallet: 108.481639584 -> 108.581536356 -> 108.704436350

Варианты мультисига:

1. статичный код vs обновляемый

По дефолту механизм обновления кода не предусмотрен. Альтернатива - можно сделать возможность обновления кода, тогда право это делать дается одному ключу (первому?). Либо делать это таким же голосованием. (Пока что без обновления)

2. с подписью всего сообщения или без

Вариант без подписи всего сообщения - это если использовать один seqno, но тогда нельзя параллельно собирать подписи на два разных запроса.
Поэтому пилим двойную подпись - сначала тело самого запрос (с его seqno), потом сообщение целиком (с текущим seqno).
У последнего будет две подписи, поэтому есть спецскрипт для отрезания лишней.

3. с get-методами или без

get-методы не очень полезны, если код статичный и обработка ответа все равно требует вызова fift-скриптов. Поэтому по умолчанию fift скрипты просто импортируют multisig-code.fif и с помощью него декодируют сериализированные данные.

Для заливки в блокчейн по умолчанию юзается multisig-code-nogetters.fc, который покороче.