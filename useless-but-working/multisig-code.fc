;; Simple wallet smart contract

(int, int, int, int, int, cell) unpack_request(req, n) {
  var (req_seqno, req_expiry, req_mode, req_sigcount, req_signatures, req_message) = (
    req~load_uint(32),
    req~load_uint(32),
    req~load_uint(8),
    req~load_uint(8),
    req~load_uint(n),
    req~load_ref()
  );
  return (req_seqno, req_expiry, req_mode, req_sigcount, req_signatures, req_message);
}

() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}

() recv_external(slice in_msg) impure {
  accept_message();
}

_ unpack_signatures(signs) {
  var l = nil;
  var owner_idx = (1 << 255) + ((1 << 255) - 1);
  do {
    (owner_idx, _, var f) = signs.udict_get_prev?(8, owner_idx);
    if (f) {
      l = cons(owner_idx, l);
    }
  } until (~ f);
  return l;
}

;; Get methods

int seqno() method_id {
  return get_data().begin_parse().preload_uint(32);
}

;; Returns number of pending requests

int pending_count() method_id {
  return get_data().begin_parse().skip_bits(32).preload_uint(16);
}

;; Returns n (total number of owners)

int param_n() method_id {
  return get_data().begin_parse().skip_bits(48).preload_uint(8);
}

;; Returns k (number of signatures required to send a message)

int param_k() method_id {
  return get_data().begin_parse().skip_bits(56).preload_uint(8);
}

;; Returns list of all owners

_ owners() method_id {
  var ds = get_data().begin_parse();
  var owners = ds~load_dict();

  var l = nil;
  var pubkey = (1 << 255) + ((1 << 255) - 1);
  do {
    (pubkey, var owner, var f) = owners.udict_get_prev?(256, pubkey);
    if (f) {
      l = cons(pair(pubkey, owner.preload_uint(8)), l);
    }
  } until (~ f);
  return l;
}

;; Returns list of all pending requests

_ pending() method_id {
  var ds = get_data().begin_parse();
  var (stored_seqno, pending_count, param_n, param_k) =
    (ds~load_uint(32), ds~load_uint(16), ds~load_uint(8), ds~load_uint(8));
  var (owners, pending) = (ds~load_dict(), ds~load_dict());
  if (pending.null?()) {
    return nil;
  }

  var l = nil;
  var req_hash = (1 << 255) + ((1 << 255) - 1);
  do {
    (req_hash, var request, var f) = pending.udict_get_prev?(256, req_hash);
    if (f) {
      var (_, req_expiry, req_mode, _, req_signatures, _) = unpack_request(request, param_n);
      l = cons(tuple4(req_hash, req_expiry, req_mode, req_signatures), l);
    }
  } until (~ f);
  return l;
}

;; Returns all pending requests that are signed or not signed by a specific owner

_ pending_signed_by(int signatory_pubkey, int filter_signed) method_id {
  var ds = get_data().begin_parse();
  var (stored_seqno, pending_count, param_n, param_k) =
    (ds~load_uint(32), ds~load_uint(16), ds~load_uint(8), ds~load_uint(8));
  var (owners, pending) = (ds~load_dict(), ds~load_dict());
  var (owner, owner_found) = owners.udict_get?(256, signatory_pubkey);
  ;; ifnot (owner_found) {
  ;;  return nil;
  ;;}
  throw_unless(36, owner_found);
  var owner_idx = owner~load_uint(8);
  var owner_mask = 1 << owner_idx;

  if (pending.null?()) {
    return nil;
  }

  var l = nil;
  var req_hash = (1 << 255) + ((1 << 255) - 1);
  do {
    (req_hash, var request, var f) = pending.udict_get_prev?(256, req_hash);
    if (f) {
      var (_, req_expiry, req_mode, _, req_signatures, _) = unpack_request(request, param_n);
      var sign_found = (req_signatures & owner_mask) != 0;

      if (filter_signed == sign_found) {
        l = cons(tuple4(req_hash, req_expiry, req_mode, req_signatures), l);
      }
    }
  } until (~ f);
  return l;
}

_ debug_test(int a, int b, int c) method_id {
  return (b, c);
}

_ debug_test2(int a, int b) method_id {
  return b;
}

_ debug_test3() method_id {
  return get_data();
}

(int, int, int, int, cell, cell, slice) debug_test4() method_id {
  var ds = get_data().begin_parse();
  var (stored_seqno, pending_count, param_n, param_k) =
    (ds~load_uint(32), ds~load_uint(16), ds~load_uint(8), ds~load_uint(8));
  var (owners, pending) = (ds~load_dict(), ds~load_dict());
  return (stored_seqno, pending_count, param_n, param_k, owners, pending, get_data().begin_parse());
}