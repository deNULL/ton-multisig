#!/usr/bin/env fift -s
"multisig-utils.fif" include

{ ."<workchain-id> <n> [<k> <filename-base>]" cr
  ."Creates a new multisig wallet with n keypairs and requiring at least k signatures, with private keys saved to or loaded from <filename-base>-<i>.pk" cr
  ."('new-ms-wallet-<i>.pk' by default)"
} : usage()

2 4 check-arg-count()

$1 parse-workchain-id =: WorkchainId
$2 (number) 1- abort"n must be an integer number" =: n
def? $3 { @' $3 (number) 1- abort"k must be an integer number" } { n } cond =: k
def? $4 { @' $4 } { "new-ms-wallet" } cond =: FileBase

."Creating new wallet in workchain " WorkchainId . cr

// Import the actual smart contract code
"multisig-code.fif" include =: WalletCode

n k initial-data() =: WalletData
."WalletData: " WalletData <s csr. cr

WalletCode WalletData null state-init() =: StateInit
."StateInit: " StateInit <s csr. cr

WorkchainId StateInit hash 2constant WalletAddr
."New wallet address = " WalletAddr .addr cr
WalletAddr FileBase +".addr" save-address-verbose

."Non-bounceable address (for init): " WalletAddr 7 .Addr cr
."Bounceable address (for later access): " WalletAddr 6 .Addr cr

0 -1 PrimaryPublicKey empty-message() =: WalletMessageBody
."Signing message: " WalletMessageBody <s csr. cr

WalletAddr StateInit
  WalletMessageBody PrimaryPrivateKey sign-message()
external-message() =: ExtMessage

."External message for initialization is " ExtMessage <s csr. cr
ExtMessage 2 boc+>B dup Bx. cr
FileBase +"-init-query.boc" tuck B>file
."(Saved wallet creating query to file " type .")" cr
