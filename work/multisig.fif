#!/usr/bin/env fift -s
"TonUtil.fif" include
"Asm.fif" include

{ ."Usage: " @' $0 type ." <workchain-id> <n> [<k> <filename-base>]" cr
  ."Creates a new multisig wallet with n keypairs and requiring at least k signatures, with private keys saved to or loaded from <filename-base>-<i>.pk" cr
  ."('new-wallet-<i>.pk' by default)" cr 1 halt
} : usage

$# dup 2 < swap 4 > or ' usage if // allow 2 to 4 arguments

$1 parse-workchain-id =: wc
$2 (number) 1- abort"n must be an integer number" =: n
def? $3 { @' $3 (number) 1- abort"k must be an integer number" } { n } cond constant k
def? $4 { @' $4 } { "new-multisig-wallet" } cond constant file-base

."Creating new wallet in workchain " wc . cr

// Import the actual smart contract code
"multisig-code.fif" include constant WalletCode

// .s -> code

// Data:
<b 0 32 u, // seqno
  0 16 u,
  n 8 u,
  k 8 u,
  0 dictnew { // Generating list of owners
    over <b swap 8 u, // Saving index to builder
    file-base +"-" 3 pick 1 + (.) $+ +".pk" load-generate-keypair // Loading/saving pubkey and privkey
      // .s -> code:cell data:builder index:int keylist:dict builder pubkey:bytes privkey:bytes
     
    4 pick 0 = { // if index == 0, this is the key we will sign our message with
      =: primary_pk
      dup =: primary_pubkey
    } { // no need for this key anymore
      drop
    } cond
    256 B>u@ // Converting pubkey to int
    ."sss: " dup x. cr
      // udict requires order: value(builder) key(pubkey) dict(keylist) n=256
    rot 256 .s b>udict!
    0= abort"Unable to store public key in the contract data"
      // .s -> code:cell data:builder index:int keylist:dict
    swap 1+ swap // Increase index
  } n times
  ."<!!!>" .s ."</!!!>" 
  swap drop
  dict, // Store map of pubkeys => indices within data section
  null dict, // Store empty dict of pending requests
  
  <b
    0 32 u, // seqno, initially 0
    -1 32 i, // valid_until, TODO: ask for a value?
    primary_pubkey B,
  b> ref,
b> constant WalletData
."WalletData: " WalletData <s csr. cr
// .s -> code data

null constant WalletLibs // no libraries

// .s -> code data libs(null)

<b
  b{0011} s,
  WalletCode ref,
  WalletData ref,
  WalletLibs dict,
b> constant StateInit
// .s -> StateInit
// ."<!!>" .s ."</!!>"

."StateInit: " StateInit <s csr. cr
wc StateInit hash 2constant WalletAddr
."new wallet address = " WalletAddr .addr cr
WalletAddr file-base +".addr" save-address-verbose

// .s -> StateInit workchain_id addr
."Non-bounceable address (for init): " WalletAddr 7 .Addr cr
."Bounceable address (for later access): " WalletAddr 6 .Addr cr

// Building initial message:
<b
  0 32 u, // seqno, initially 0
  -1 32 i, // valid_until, TODO: ask for a value?
  primary_pubkey B,
b> constant WalletMessageBody

."signing message: " WalletMessageBody <s csr. cr

."Your primary pubkey is: 0x" primary_pubkey Bx. cr

// .s -> StateInit Message

WalletMessageBody hash primary_pk ed25519_sign_uint constant WalletMessageSign

// .s -> Message signature(512b) StateInit

<b
// b{10} = ext_in_msg_info;
//   b{00} = addr_none; src
//     b{10} = addr_std; dst
//       b{0} = incl. anycast?=no
  b{1000100} s, WalletAddr addr,
  
// b{0000} = import_fee=0 Grams
//     b{1} = incl. StateInit?=yes
//       b{0} = StateInit in ref?=no (inlined)
  b{000010} s,
  StateInit <s s,
  b{1} s,
  <b
    WalletMessageSign B, WalletMessageBody <s s,
  b> ref,
b> constant ExtMessage

."External message for initialization is " ExtMessage <s csr. cr
ExtMessage 2 boc+>B dup Bx. cr
file-base +"-query.boc" tuck B>file
."(Saved wallet creating query to file " type .")" cr
