;; Simple wallet smart contract

(int, int, int, int, int, cell) unpack_request(req, n) {
  var (req_seqno, req_expiry, req_mode, req_sigcount, req_signatures, req_message) = (
    req~load_uint(32),
    req~load_uint(32),
    req~load_uint(8),
    req~load_uint(8),
    req~load_uint(n),
    req~load_ref()
  );
  return (req_seqno, req_expiry, req_mode, req_sigcount, req_signatures, req_message);
}

() ext_process(slice in_msg) {
  ;; usual signature, seqno, expiry date
  var signature = in_msg~load_bits(512);
  var cs = in_msg;
  var (msg_seqno, valid_until) = (cs~load_uint(32), cs~load_uint(32));
  throw_if(35, valid_until < now());

  ;; pubkey of the person who signed this message
  ;; should be included in the list of allowed keys (within this wallet data)
  var signatory_pubkey = cs~load_uint(256);

  var ds = get_data().begin_parse();
  ;; seqno,
  ;; number of requests pending,
  ;; total number of stored keys, 
  ;; required number of signatures to complete signature
  var (stored_seqno, pending_count, param_n, param_k) =
    (ds~load_uint(32), ds~load_uint(16), ds~load_uint(8), ds~load_uint(8));

  throw_unless(33, msg_seqno == stored_seqno);
  throw_unless(34, check_signature(slice_hash(in_msg), signature, signatory_pubkey));

  ;; dict of {stored pubkey => #key},
  ;; dict of {#request => request},
  var (owners, pending) = (ds~load_dict(), ds~load_dict());
  ds.end_parse();

  ;; validate that signatory_pubkey is among stored keys
  var (_, found) = owners.udict_get?(256, signatory_pubkey);
  throw_unless(35, found);

  accept_message();

  ;; iterate over pending requests and delete all expired ones
  var req_hash = -1;
  var l = nil;
  var f = 0;
  do {
    (req_hash, var request, f) = pending.udict_get_next?(256, req_hash);
    if (f) {
      var (req_signs, req_body) = (request~load_dict(), request~load_ref());
      var req_body_slice = req_body.begin_parse();
      var (_, req_expiry) = (
        req_body_slice~load_uint(32),
        req_body_slice~load_uint(32)
      );
      if (req_expiry >= now()) {
        l = cons(req_hash, l);
      }
    }
  } until (~ f);

  ifnot (l.null?()) {
    do {
      req_hash = l~list_next();
      pending~udict_delete_get?(256, req_hash);
    } until (l.null?());
  }

  ;; process new request
  cs~touch();
  while (cs.slice_refs()) {
    ;;var (req_expiry, req_mode) = (cs~load_uint(8), cs~load_uint(32));
    var (req_hash, req_seqno, req_expiry, req_mode, req_sigcount, req_signatures) = (0, 0, 0, 0, 0, 0);
    var (req_body, req_message) = (begin_cell().end_cell(), begin_cell().end_cell());

    var existing = cs~load_uint(1);
    if (existing) {
      req_hash = cs~load_uint(256);
    } else {
      var req_body = cs~load_ref();
      req_hash = cell_hash(req_body);

      var req_body_slice = req_body.begin_parse();
      (req_seqno, req_expiry, req_mode) = (
        req_body_slice~load_uint(32),
        req_body_slice~load_uint(32),
        req_body_slice~load_uint(8)
      );
      req_message = req_body_slice~load_ref();
    }

    var req_new_signs = cs~load_dict();

    ;; validate expiry
    throw_if(36, req_expiry < now());

    ;; check if this request is already pending
    var (req_data, found) = pending.udict_get?(256, req_hash);
    if (found) {
      (req_seqno, req_expiry, req_mode, req_sigcount, req_signatures, req_message) = unpack_request(req_data, param_n);
    } else {
      ;; we provided only the hash, but the body was not found among pending requests
      ;; (already completed/expired?)
      throw_unless(37, existing);
      ;; request should contain actual seqno of this contract,
      ;; but it's validate only when the first batch of signatures arrive
      ;; (it cannot increase, because it's included in signed part,
      ;; and after the first accepted message it won't be equal to the contract's seqno)
      throw_unless(38, req_seqno == stored_seqno);
    }

    ;; merge new signatures into req_signs
    var pubkey = -1;
    do {
      (pubkey, var sign, var f) = req_new_signs.udict_get_next?(256, pubkey);
      if (f) {
        var (owner, owner_found) = owners.udict_get?(256, pubkey);
        ;; this signature does not belong to any owner
        throw_unless(39, owner_found);

        ;; check that signature is valid
        var req_signature = sign~load_bits(512);
        throw_unless(40, check_signature(req_hash, req_signature, pubkey));

        ;; check that this request was not signed by this owner previously
        ;; (to prevent adding same signature over and over again)
        var owner_idx = owner~load_uint(8);
        var owner_mask = 1 << owner_idx;
        ifnot (req_signatures & owner_mask) {
          req_sigcount += 1;
          req_signatures = req_signatures | owner_mask;
        }
      }
    } until (~ f);

    if (req_sigcount >= param_k) {
      ;; enough signatures to send this message
      send_raw_message(req_message, req_mode);

      ;; make sure it's removed
      pending~udict_delete_get?(256, req_hash);
    } else {
      ;; store message as pending request
      pending~udict_set_builder(256, req_hash, begin_cell()
        .store_uint(req_seqno, 32)
        .store_uint(req_expiry, 32)
        .store_uint(req_mode, 8)
        .store_uint(req_sigcount, 8)
        .store_uint(req_signatures, param_n)
        .store_ref(req_message));
    }
  }
  cs.end_parse();

  set_data(
    begin_cell()
      .store_uint(stored_seqno + 1, 32)
      .store_uint(pending_count, 16)
      .store_uint(param_n, 8)
      .store_uint(param_k, 8)
      .store_dict(owners)
      .store_dict(pending)
    .end_cell()
  );
}

() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}

() recv_external(slice in_msg) impure {
  accept_message();
}

;; Get methods

int seqno() method_id {
  return get_data().begin_parse().preload_uint(32);
}

;; Returns number of pending requests

int pending_count() method_id {
  return get_data().begin_parse().skip_bits(32).preload_uint(16);
}

;; Returns n (total number of owners)

int param_n() method_id {
  return get_data().begin_parse().skip_bits(48).preload_uint(8);
}

;; Returns k (number of signatures required to send a message)

int param_k() method_id {
  return get_data().begin_parse().skip_bits(56).preload_uint(8);
}

;; Returns list of all owners

_ owners() method_id {
  var ds = get_data().begin_parse();
  var (stored_seqno, pending_count, param_n, param_k) =
    (ds~load_uint(32), ds~load_uint(16), ds~load_uint(8), ds~load_uint(8));
  var owners = ds~load_dict();

  var l = nil;
  var pubkey = (1 << 255) + ((1 << 255) - 1);
  do {
    (pubkey, var owner, var f) = owners.udict_get_prev?(256, pubkey);
    if (f) {
      l = cons(pair(pubkey, owner.preload_uint(8)), l);
    }
  } until (~ f);
  return l;
}

;; Returns list of all pending requests

_ pending() method_id {
  var ds = get_data().begin_parse();
  var (stored_seqno, pending_count, param_n, param_k) =
    (ds~load_uint(32), ds~load_uint(16), ds~load_uint(8), ds~load_uint(8));
  var (owners, pending) = (ds~load_dict(), ds~load_dict());
  if (pending.null?()) {
    return nil;
  }

  var l = nil;
  var req_hash = (1 << 255) + ((1 << 255) - 1);
  do {
    (req_hash, var request, var f) = pending.udict_get_prev?(256, req_hash);
    if (f) {
      var (_, req_expiry, req_mode, _, req_signatures, _) = unpack_request(request, param_n);
      l = cons(tuple4(req_hash, req_expiry, req_mode, req_signatures), l);
    }
  } until (~ f);
  return l;
}

;; Returns all pending requests that are signed or not signed by a specific owner

_ pending_signed_by(int signatory_pubkey, int filter_signed) method_id {
  var ds = get_data().begin_parse();
  var (stored_seqno, pending_count, param_n, param_k) =
    (ds~load_uint(32), ds~load_uint(16), ds~load_uint(8), ds~load_uint(8));
  var (owners, pending) = (ds~load_dict(), ds~load_dict());
  var (owner, owner_found) = owners.udict_get?(256, signatory_pubkey);
  ;; ifnot (owner_found) {
  ;;  return nil;
  ;;}
  throw_unless(36, owner_found);
  var owner_idx = owner~load_uint(8);
  var owner_mask = 1 << owner_idx;

  if (pending.null?()) {
    return nil;
  }

  var l = nil;
  var req_hash = (1 << 255) + ((1 << 255) - 1);
  do {
    (req_hash, var request, var f) = pending.udict_get_prev?(256, req_hash);
    if (f) {
      var (_, req_expiry, req_mode, _, req_signatures, _) = unpack_request(request, param_n);
      var sign_found = (req_signatures & owner_mask) != 0;

      if (filter_signed == sign_found) {
        l = cons(tuple4(req_hash, req_expiry, req_mode, req_signatures), l);
      }
    }
  } until (~ f);
  return l;
}

_ debug_test(int a, int b, int c) method_id {
  return (b, c);
}

_ debug_test2(int a, int b) method_id {
  return b;
}

_ debug_test3() method_id {
  return get_data();
}

(int, int, int, int, cell, cell, slice) debug_test4() method_id {
  var ds = get_data().begin_parse();
  var (stored_seqno, pending_count, param_n, param_k) =
    (ds~load_uint(32), ds~load_uint(16), ds~load_uint(8), ds~load_uint(8));
  var (owners, pending) = (ds~load_dict(), ds~load_dict());
  return (stored_seqno, pending_count, param_n, param_k, owners, pending, get_data().begin_parse());
}

_ debug_test5(slice in_msg) method_id {
  ext_process(in_msg);
}

() debug_test6() method_id {
  var ds = get_data().begin_parse();
  var (stored_seqno, pending_count, param_n, param_k) =
    (ds~load_uint(32), ds~load_uint(16), ds~load_uint(8), ds~load_uint(8));
  var (owners, pending) = (ds~load_dict(), ds~load_dict());

  var msg = ds~load_ref().begin_parse();
  return ext_process(msg);
}